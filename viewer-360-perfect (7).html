<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="360 Viewer">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#667eea">
<link rel="manifest" href="./manifest.json">
<link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 200'%3E%3Ccircle cx='100' cy='100' r='90' fill='%23667eea'/%3E%3Ctext x='100' y='130' font-size='100' text-anchor='middle' fill='white'%3E360%3C/text%3E%3C/svg%3E">
<title>Viewer 360 Pro</title>
<style>
* { 
    margin: 0; 
    padding: 0; 
    box-sizing: border-box; 
    -webkit-tap-highlight-color: transparent; 
    -webkit-touch-callout: none; 
    -webkit-user-select: none; 
    user-select: none; 
}

body { 
    background: #000; 
    overflow: hidden; 
    height: 100vh; 
    width: 100vw; 
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; 
    position: fixed; 
}

#container { 
    width: 100%; 
    height: 100%; 
    touch-action: none; 
}

.ui-element { 
    transition: opacity 0.3s, transform 0.3s; 
}

.ui-element.hidden { 
    opacity: 0; 
    pointer-events: none; 
}

#ui { 
    position: fixed; 
    bottom: 30px; 
    left: 50%; 
    transform: translateX(-50%); 
    background: rgba(0,0,0,0.6); 
    padding: 20px; 
    border-radius: 20px; 
    display: flex; 
    gap: 12px; 
    z-index: 100; 
    box-shadow: 0 8px 32px rgba(0,0,0,0.8); 
    backdrop-filter: blur(10px); 
    -webkit-backdrop-filter: blur(10px); 
}

#ui.hidden { 
    transform: translateX(-50%) translateY(150%); 
}

button { 
    background: #808080; 
    border: none; 
    color: white; 
    padding: 16px 24px; 
    border-radius: 14px; 
    font-size: 18px; 
    font-weight: 600; 
    cursor: pointer; 
    transition: all 0.2s; 
    min-width: 60px; 
    touch-action: manipulation; 
}

button:active { 
    background: #a0a0a0; 
    transform: scale(0.95); 
}

#load { 
    background: linear-gradient(135deg, #667eea, #764ba2); 
}

#gyro { 
    background: linear-gradient(135deg, #f093fb, #f5576c); 
}

#gyro.active { 
    background: linear-gradient(135deg, #11998e, #38ef7d); 
}

#toggleUI { 
    position: fixed; 
    top: 20px; 
    right: 20px; 
    background: rgba(0,0,0,0.6); 
    backdrop-filter: blur(10px); 
    -webkit-backdrop-filter: blur(10px); 
    color: white; 
    padding: 12px 16px; 
    border-radius: 12px; 
    z-index: 102; 
    font-size: 20px; 
}

#nav { 
    position: fixed; 
    top: 50%; 
    transform: translateY(-50%); 
    width: 100%; 
    display: flex; 
    justify-content: space-between; 
    padding: 0 20px; 
    z-index: 100; 
    pointer-events: none; 
}

#nav.hidden { 
    opacity: 0; 
}

#nav button { 
    pointer-events: all; 
    background: rgba(0,0,0,0.6); 
    backdrop-filter: blur(10px); 
    -webkit-backdrop-filter: blur(10px); 
    padding: 20px 16px; 
    font-size: 24px; 
}

#nav button:disabled { 
    opacity: 0.3; 
    pointer-events: none; 
}

input { 
    display: none; 
}

#info { 
    position: fixed; 
    top: 30px; 
    left: 50%; 
    transform: translateX(-50%); 
    background: rgba(0,0,0,0.6); 
    backdrop-filter: blur(10px); 
    -webkit-backdrop-filter: blur(10px); 
    color: white; 
    padding: 16px 32px; 
    border-radius: 16px; 
    z-index: 100; 
    text-align: center; 
    font-size: 16px; 
    max-width: 90%; 
    box-shadow: 0 4px 16px rgba(0,0,0,0.6); 
}

#info.hidden { 
    transform: translateX(-50%) translateY(-150%); 
}

#loading { 
    position: fixed; 
    top: 50%; 
    left: 50%; 
    transform: translate(-50%, -50%); 
    background: rgba(0,0,0,0.9); 
    backdrop-filter: blur(20px); 
    -webkit-backdrop-filter: blur(20px); 
    color: white; 
    padding: 40px 60px; 
    border-radius: 20px; 
    display: none; 
    z-index: 200; 
    font-size: 20px; 
}

.spinner { 
    width: 50px; 
    height: 50px; 
    margin: 20px auto 0; 
    border: 4px solid rgba(255,255,255,0.3); 
    border-top: 4px solid white; 
    border-radius: 50%; 
    animation: spin 1s linear infinite; 
}

@keyframes spin { 
    0% { transform: rotate(0deg); } 
    100% { transform: rotate(360deg); } 
}

#counter { 
    position: fixed; 
    top: 30px; 
    right: 80px; 
    background: rgba(0,0,0,0.6); 
    backdrop-filter: blur(10px); 
    -webkit-backdrop-filter: blur(10px); 
    color: white; 
    padding: 12px 20px; 
    border-radius: 12px; 
    z-index: 100; 
    font-size: 16px; 
    font-weight: 600; 
    display: none; 
}

#counter.hidden { 
    transform: translateY(-150%); 
}

#fps { 
    position: fixed; 
    bottom: 30px; 
    right: 30px; 
    background: rgba(0,0,0,0.6); 
    backdrop-filter: blur(10px); 
    -webkit-backdrop-filter: blur(10px); 
    color: white; 
    padding: 12px 20px; 
    border-radius: 12px; 
    z-index: 100; 
    font-size: 14px; 
    display: block;
}

#fps.hidden { 
    transform: translateY(150%); 
}
</style>
</head>
<body>
<div id="info" class="ui-element">üåê Viewer 360 Pro</div>
<div id="counter" class="ui-element">1/1</div>
<div id="fps" class="ui-element">60 FPS</div>
<button id="toggleUI">üëÅÔ∏è</button>
<div id="loading">Caricamento...<div class="spinner"></div></div>
<div id="container"></div>
<div id="nav" class="ui-element">
    <button id="prevBtn" disabled>‚óÑ</button>
    <button id="nextBtn" disabled>‚ñ∫</button>
</div>
<div id="ui" class="ui-element">
    <button id="load">üì∑</button>
    <input type="file" id="f" accept="image/*" multiple>
    <button id="gyro">üì±</button>
    <button id="zoomIn">+</button>
    <button id="zoomOut">‚àí</button>
    <button id="resetBtn">‚Ü∫</button>
</div>

<!-- Three.js LOCALE per funzionamento offline -->
<script src="./three.min.js"></script>

<script>
// Nascondi loading screen
document.getElementById('loading').style.display = 'none';

// Verifica caricamento Three.js
if (typeof THREE === 'undefined') {
    document.getElementById('loading').style.display = 'block';
    document.getElementById('loading').innerHTML = '<div style="color:#ff4444;">‚ùå Errore: three.min.js non trovato!<br><br>Assicurati che three.min.js sia caricato su GitHub nella stessa cartella.</div>';
    throw new Error('Three.js non caricato');
}

console.log('‚úÖ Three.js caricato dalla versione locale');
console.log('üì¶ Versione:', THREE.REVISION);


// ============================================
// IL CODICE DELL'APP INIZIA QUI
// ============================================
// ============================================
// VARIABILI GLOBALI
// ============================================
let scene, camera, renderer, sphere;
let textures = [];
let currentIndex = 0;

const container = document.getElementById('container');
const elements = {
    info: document.getElementById('info'),
    loading: document.getElementById('loading'),
    gyroBtn: document.getElementById('gyro'),
    loadBtn: document.getElementById('load'),
    zoomInBtn: document.getElementById('zoomIn'),
    zoomOutBtn: document.getElementById('zoomOut'),
    resetBtn: document.getElementById('resetBtn'),
    toggleUIBtn: document.getElementById('toggleUI'),
    fileInput: document.getElementById('f'),
    prevBtn: document.getElementById('prevBtn'),
    nextBtn: document.getElementById('nextBtn'),
    counter: document.getElementById('counter'),
    fps: document.getElementById('fps')
};

let state = {
    gyroActive: false,
    initialAlpha: null,
    initialBeta: null,
    initialGamma: null,
    deviceOrientation: 0,
    rotationOffset: { x: 0, y: 0 },
    uiVisible: true,
    isDragging: false,
    previousMousePosition: { x: 0, y: 0 },
    targetRotation: { x: 0, y: 0 },
    currentRotation: { x: 0, y: 0 }
};

let lastTime = performance.now();
let frames = 0;

// ============================================
// INIZIALIZZAZIONE THREE.JS
// ============================================
function initThreeJS() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 0);
    
    renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        powerPreference: "high-performance",
        precision: "highp"
    });
    
    const pixelRatio = Math.min(window.devicePixelRatio, 2);
    renderer.setPixelRatio(pixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);
    
    const geometry = new THREE.SphereGeometry(500, 128, 128);
    geometry.scale(-1, 1, 1);
    
    const material = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide
    });
    
    sphere = new THREE.Mesh(geometry, material);
    scene.add(sphere);
    
    window.addEventListener('resize', onWindowResize);
    setupControls();
    animate();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// ============================================
// CONTROLLI
// ============================================
function setupControls() {
    const canvas = renderer.domElement;
    
    canvas.addEventListener('mousedown', onMouseDown);
    canvas.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('wheel', onMouseWheel, { passive: false });
    
    canvas.addEventListener('touchstart', onTouchStart, { passive: false });
    canvas.addEventListener('touchmove', onTouchMove, { passive: false });
    canvas.addEventListener('touchend', onTouchEnd);
    
    document.addEventListener('keydown', onKeyDown);
}

function onMouseDown(event) {
    if (state.gyroActive) return;
    state.isDragging = true;
    state.previousMousePosition = { x: event.clientX, y: event.clientY };
}

function onMouseMove(event) {
    if (!state.isDragging || state.gyroActive) return;
    
    const deltaMove = {
        x: event.clientX - state.previousMousePosition.x,
        y: event.clientY - state.previousMousePosition.y
    };
    
    state.targetRotation.y += deltaMove.x * 0.005;
    state.targetRotation.x += deltaMove.y * 0.005;
    state.targetRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, state.targetRotation.x));
    
    state.previousMousePosition = { x: event.clientX, y: event.clientY };
}

function onMouseUp() {
    state.isDragging = false;
}

function onMouseWheel(event) {
    event.preventDefault();
    const delta = event.deltaY * 0.05;
    camera.fov = Math.max(30, Math.min(120, camera.fov + delta));
    camera.updateProjectionMatrix();
}

let lastTouchX = 0;
let lastTouchY = 0;
let touchStartDistance = 0;
let touchStartFov = 75;

function onTouchStart(event) {
    event.preventDefault();
    if (state.gyroActive) return;
    
    if (event.touches.length === 1) {
        state.isDragging = true;
        lastTouchX = event.touches[0].clientX;
        lastTouchY = event.touches[0].clientY;
    } else if (event.touches.length === 2) {
        const dx = event.touches[0].clientX - event.touches[1].clientX;
        const dy = event.touches[0].clientY - event.touches[1].clientY;
        touchStartDistance = Math.sqrt(dx * dx + dy * dy);
        touchStartFov = camera.fov;
    }
}

function onTouchMove(event) {
    event.preventDefault();
    if (state.gyroActive) return;
    
    if (event.touches.length === 1 && state.isDragging) {
        const deltaX = event.touches[0].clientX - lastTouchX;
        const deltaY = event.touches[0].clientY - lastTouchY;
        
        state.targetRotation.y += deltaX * 0.005;
        state.targetRotation.x += deltaY * 0.005;
        state.targetRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, state.targetRotation.x));
        
        lastTouchX = event.touches[0].clientX;
        lastTouchY = event.touches[0].clientY;
    } else if (event.touches.length === 2) {
        const dx = event.touches[0].clientX - event.touches[1].clientX;
        const dy = event.touches[0].clientY - event.touches[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        const factor = touchStartDistance / distance;
        camera.fov = Math.max(30, Math.min(120, touchStartFov * factor));
        camera.updateProjectionMatrix();
    }
}

function onTouchEnd(event) {
    if (event.touches.length === 0) {
        state.isDragging = false;
    }
}

function onKeyDown(event) {
    switch(event.key) {
        case 'ArrowLeft': changeImage(-1); break;
        case 'ArrowRight': changeImage(1); break;
        case 'h': case 'H': toggleUI(); break;
        case 'r': case 'R': resetView(); break;
    }
}

// ============================================
// CARICAMENTO IMMAGINI
// ============================================
function loadImageFromFile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = () => reject(new Error('Impossibile caricare immagine'));
            img.src = e.target.result;
        };
        reader.onerror = () => reject(new Error('Impossibile leggere file'));
        reader.readAsDataURL(file);
    });
}

async function loadImages(files) {
    console.log('üì∑ Caricamento', files.length, 'immagini...');
    elements.loading.style.display = 'block';
    elements.info.textContent = '‚è≥ Caricamento...';
    
    textures = [];
    currentIndex = 0;
    
    for (let i = 0; i < files.length; i++) {
        try {
            console.log(`üì∏ Carico immagine ${i + 1}/${files.length}:`, files[i].name);
            const img = await loadImageFromFile(files[i]);
            console.log(`‚úÖ Immagine caricata:`, img.width, 'x', img.height);
            
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            
            const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
            texture.anisotropy = Math.min(maxAnisotropy, 8);
            
            console.log('üé® Texture creata, anisotropy:', texture.anisotropy);
            
            textures.push(texture);
            elements.info.textContent = `‚è≥ ${i + 1}/${files.length}...`;
        } catch (error) {
            console.error('‚ùå Errore caricamento immagine:', error);
        }
    }
    
    elements.loading.style.display = 'none';
    
    if (textures.length > 0) {
        console.log('üåê Applico texture alla sfera...');
        sphere.material.map = textures[0];
        sphere.material.needsUpdate = true;
        
        console.log('‚úÖ Material aggiornato:', sphere.material);
        console.log('üì¶ Texture size:', textures[0].image.width, 'x', textures[0].image.height);
        
        for (let i = 0; i < 3; i++) {
            renderer.render(scene, camera);
        }
        
        elements.info.textContent = '‚úÖ ' + textures.length + ' immagini';
        updateNavButtons();
        updateCounter();
        
        console.log('üéâ Immagini caricate con successo!');
    } else {
        console.warn('‚ö†Ô∏è Nessuna texture caricata');
    }
}

elements.fileInput.addEventListener('change', (e) => {
    const files = Array.from(e.target.files);
    if (files.length > 0) loadImages(files);
});

// ============================================
// NAVIGAZIONE
// ============================================
function changeImage(delta) {
    if (textures.length === 0) return;
    
    currentIndex += delta;
    if (currentIndex < 0) currentIndex = textures.length - 1;
    if (currentIndex >= textures.length) currentIndex = 0;
    
    sphere.material.map = textures[currentIndex];
    sphere.material.needsUpdate = true;
    
    updateNavButtons();
    updateCounter();
    renderer.render(scene, camera);
}

function updateNavButtons() {
    elements.prevBtn.disabled = textures.length <= 1;
    elements.nextBtn.disabled = textures.length <= 1;
}

function updateCounter() {
    if (textures.length > 1) {
        elements.counter.style.display = 'block';
        elements.counter.textContent = (currentIndex + 1) + '/' + textures.length;
    } else {
        elements.counter.style.display = 'none';
    }
}

// ============================================
// GIROSCOPIO - VERSIONE FINALE OTTIMIZZATA
// ============================================
function toggleGyro() {
    if (textures.length === 0) {
        showInfo('‚ö†Ô∏è Carica immagini prima!');
        return;
    }
    state.gyroActive ? stopGyro() : enableGyro();
}

function enableGyro() {
    if (typeof DeviceOrientationEvent !== 'undefined' && 
        typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission().then(response => {
            if (response === 'granted') startGyro();
            else showInfo('‚ùå Permesso negato');
        }).catch(() => showInfo('‚ùå Errore'));
    } else {
        startGyro();
    }
}

function startGyro() {
    state.gyroActive = true;
    state.initialAlpha = null;
    state.initialBeta = null;
    state.initialGamma = null;
    
    elements.gyroBtn.classList.add('active');
    elements.gyroBtn.textContent = 'üì± ON';
    
    window.addEventListener('deviceorientation', handleOrientation, true);
    showInfo('üì± Giroscopio attivo');
}

function stopGyro() {
    state.gyroActive = false;
    elements.gyroBtn.classList.remove('active');
    elements.gyroBtn.textContent = 'üì±';
    window.removeEventListener('deviceorientation', handleOrientation, true);
    showInfo('üåê Giroscopio disattivato');
}

function handleOrientation(event) {
    if (!state.gyroActive) return;
    
    let alpha = event.alpha || 0;
    let beta = event.beta || 0;
    let gamma = event.gamma || 0;
    
    if (event.webkitCompassHeading !== undefined) {
        alpha = event.webkitCompassHeading;
    }
    
    const orientation = window.orientation || 0;
    
    // Inizializzazione o cambio orientamento
    if (state.initialAlpha === null || state.deviceOrientation !== orientation) {
        if (state.deviceOrientation !== orientation) {
            state.deviceOrientation = orientation;
            const orientName = orientation === 0 ? 'Portrait' : orientation === 90 ? 'Landscape ‚ü≤' : 'Landscape ‚ü≥';
            showInfo('üîÑ ' + orientName, 1500);
        }
        
        state.initialAlpha = alpha;
        state.initialBeta = beta;
        state.initialGamma = gamma;
        state.rotationOffset = {
            y: state.currentRotation.y,
            x: state.currentRotation.x
        };
        return;
    }
    
    // Calcola delta
    let deltaAlpha = alpha - state.initialAlpha;
    let deltaBeta = beta - state.initialBeta;
    let deltaGamma = gamma - state.initialGamma;
    
    // Normalizza
    while (deltaAlpha > 180) deltaAlpha -= 360;
    while (deltaAlpha < -180) deltaAlpha += 360;
    while (deltaBeta > 180) deltaBeta -= 360;
    while (deltaBeta < -180) deltaBeta += 360;
    while (deltaGamma > 180) deltaGamma -= 360;
    while (deltaGamma < -180) deltaGamma += 360;
    
    let targetY, targetX;
    
    if (orientation === 0) {
        // PORTRAIT - funziona bene
        targetY = state.rotationOffset.y + THREE.MathUtils.degToRad(-deltaAlpha);
        targetX = state.rotationOffset.x + THREE.MathUtils.degToRad(deltaBeta);
        
    } else if (orientation === 90) {
        // LANDSCAPE LEFT
        // SOLUZIONE: quando beta √® vicino a ¬±90¬∞, usa formula alternativa
        
        if (Math.abs(beta) > 60) {
            // Vicino al gimbal lock - usa combinazione diversa
            // Quando guardi molto in alto/basso, alpha e gamma si mescolano
            const sign = beta > 0 ? 1 : -1;
            targetY = state.rotationOffset.y + THREE.MathUtils.degToRad(-deltaAlpha - deltaGamma * sign * 0.5);
            targetX = state.rotationOffset.x + THREE.MathUtils.degToRad(-deltaGamma);
        } else {
            // Normale - lontano dal gimbal lock
            targetY = state.rotationOffset.y + THREE.MathUtils.degToRad(-deltaAlpha);
            targetX = state.rotationOffset.x + THREE.MathUtils.degToRad(-deltaGamma);
        }
        
    } else if (orientation === -90) {
        // LANDSCAPE RIGHT
        
        if (Math.abs(beta) > 60) {
            const sign = beta > 0 ? 1 : -1;
            targetY = state.rotationOffset.y + THREE.MathUtils.degToRad(-deltaAlpha + deltaGamma * sign * 0.5);
            targetX = state.rotationOffset.x + THREE.MathUtils.degToRad(deltaGamma);
        } else {
            targetY = state.rotationOffset.y + THREE.MathUtils.degToRad(-deltaAlpha);
            targetX = state.rotationOffset.x + THREE.MathUtils.degToRad(deltaGamma);
        }
        
    } else {
        // PORTRAIT UPSIDE DOWN
        targetY = state.rotationOffset.y + THREE.MathUtils.degToRad(-deltaAlpha + 180);
        targetX = state.rotationOffset.x + THREE.MathUtils.degToRad(-deltaBeta);
    }
    
    // Calcola differenza
    let diffY = targetY - state.targetRotation.y;
    let diffX = targetX - state.targetRotation.x;
    
    // Normalizza
    while (diffY > Math.PI) diffY -= Math.PI * 2;
    while (diffY < -Math.PI) diffY += Math.PI * 2;
    while (diffX > Math.PI) diffX -= Math.PI * 2;
    while (diffX < -Math.PI) diffX += Math.PI * 2;
    
    // Solo in portrait facciamo anti-glitch
    if (orientation === 0 && (Math.abs(diffY) > Math.PI / 2 || Math.abs(diffX) > Math.PI / 2)) {
        state.initialAlpha = alpha;
        state.initialBeta = beta;
        state.initialGamma = gamma;
        state.rotationOffset = {
            y: state.currentRotation.y,
            x: state.currentRotation.x
        };
        return;
    }
    
    // Applica con damping maggiore vicino al gimbal lock
    const dampingFactor = Math.abs(beta) > 60 ? 0.3 : 1.0;
    
    state.targetRotation.y += diffY * dampingFactor;
    state.targetRotation.x += diffX * dampingFactor;
    
    // Limita pitch
    state.targetRotation.x = Math.max(-Math.PI / 2.1, Math.min(Math.PI / 2.1, state.targetRotation.x));
}

// ============================================
// UI
// ============================================
function toggleUI() {
    state.uiVisible = !state.uiVisible;
    const uiElements = document.querySelectorAll('.ui-element');
    uiElements.forEach(el => {
        if (state.uiVisible) el.classList.remove('hidden');
        else el.classList.add('hidden');
    });
    elements.toggleUIBtn.textContent = state.uiVisible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è';
}

function showInfo(text, duration = 2000) {
    elements.info.textContent = text;
    setTimeout(() => {
        if (textures.length > 0) {
            elements.info.textContent = '‚úÖ ' + textures.length + ' immagini';
        } else {
            elements.info.textContent = 'üåê Viewer 360 Pro';
        }
    }, duration);
}

function zoomIn() {
    camera.fov = Math.max(30, camera.fov - 5);
    camera.updateProjectionMatrix();
}

function zoomOut() {
    camera.fov = Math.min(120, camera.fov + 5);
    camera.updateProjectionMatrix();
}

function resetView() {
    state.targetRotation.x = 0;
    state.targetRotation.y = 0;
    state.currentRotation.x = 0;
    state.currentRotation.y = 0;
    camera.fov = 75;
    camera.updateProjectionMatrix();
    
    if (state.gyroActive) {
        state.initialAlpha = null;
        state.initialBeta = null;
        state.initialGamma = null;
    }
}

// ============================================
// EVENT LISTENERS
// ============================================
elements.loadBtn.addEventListener('click', () => elements.fileInput.click());
elements.loadBtn.addEventListener('touchend', (e) => { e.preventDefault(); elements.fileInput.click(); });

elements.gyroBtn.addEventListener('click', toggleGyro);
elements.gyroBtn.addEventListener('touchend', (e) => { e.preventDefault(); toggleGyro(); });

elements.zoomInBtn.addEventListener('click', zoomIn);
elements.zoomInBtn.addEventListener('touchend', (e) => { e.preventDefault(); zoomIn(); });

elements.zoomOutBtn.addEventListener('click', zoomOut);
elements.zoomOutBtn.addEventListener('touchend', (e) => { e.preventDefault(); zoomOut(); });

elements.resetBtn.addEventListener('click', resetView);
elements.resetBtn.addEventListener('touchend', (e) => { e.preventDefault(); resetView(); });

elements.toggleUIBtn.addEventListener('click', toggleUI);
elements.toggleUIBtn.addEventListener('touchend', (e) => { e.preventDefault(); toggleUI(); });

elements.prevBtn.addEventListener('click', () => changeImage(-1));
elements.prevBtn.addEventListener('touchend', (e) => { e.preventDefault(); changeImage(-1); });

elements.nextBtn.addEventListener('click', () => changeImage(1));
elements.nextBtn.addEventListener('touchend', (e) => { e.preventDefault(); changeImage(1); });

// ============================================
// ANIMAZIONE
// ============================================
function animate() {
    requestAnimationFrame(animate);
    
    // Smoothing molto alto per giroscopio = movimenti fluidi
    const smoothing = state.gyroActive ? 0.35 : 0.1;
    
    let diffX = state.targetRotation.x - state.currentRotation.x;
    let diffY = state.targetRotation.y - state.currentRotation.y;
    
    while (diffY > Math.PI) diffY -= Math.PI * 2;
    while (diffY < -Math.PI) diffY += Math.PI * 2;
    
    state.currentRotation.x += diffX * smoothing;
    state.currentRotation.y += diffY * smoothing;
    
    camera.rotation.order = 'YXZ';
    camera.rotation.y = state.currentRotation.y;
    camera.rotation.x = state.currentRotation.x;
    
    renderer.render(scene, camera);
    
    frames++;
    const currentTime = performance.now();
    if (currentTime >= lastTime + 1000) {
        const fps = Math.round(frames);
        elements.fps.textContent = fps + ' FPS';
        
        if (fps < 30) elements.fps.style.background = 'rgba(255,0,0,0.6)';
        else if (fps < 50) elements.fps.style.background = 'rgba(255,165,0,0.6)';
        else elements.fps.style.background = 'rgba(0,0,0,0.6)';
        
        frames = 0;
        lastTime = currentTime;
    }
}

// ============================================
// INIZIALIZZAZIONE
// ============================================
initThreeJS();

window.addEventListener('orientationchange', () => {
    if (state.gyroActive) {
        setTimeout(() => {
            state.initialAlpha = null;
            state.initialBeta = null;
            state.initialGamma = null;
        }, 500);
    }
});

// ============================================
// SERVICE WORKER - PWA OFFLINE
// ============================================
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
            .then(registration => {
                console.log('‚úÖ Service Worker registrato:', registration.scope);
            })
            .catch(error => {
                console.log('‚ùå Service Worker fallito:', error);
            });
    });
}

// Gestisci installazione PWA
let deferredPrompt;
window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    console.log('üíæ PWA installabile');
});

// Notifica quando installata
window.addEventListener('appinstalled', () => {
    console.log('‚úÖ PWA installata!');
    showInfo('‚úÖ App installata!', 3000);
});

</script>
</body>
</html>
